
CREATE POLICY "Sales and admins can insert leads"
  ON leads FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Sales and admins can update leads"
  ON leads FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Only admins can delete leads"
  ON leads FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Courses table
CREATE TABLE IF NOT EXISTS courses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code text NOT NULL UNIQUE,
  title text NOT NULL,
  category text NOT NULL CHECK (category IN ('excavator', 'telehandler', 'forklift', 'mewp', 'supervisor')),
  duration_days integer NOT NULL DEFAULT 1,
  delivery_mode text NOT NULL DEFAULT 'yard' CHECK (delivery_mode IN ('online', 'classroom', 'yard')),
  price_per_person decimal(10,2) NOT NULL DEFAULT 0,
  accreditation text NOT NULL DEFAULT 'CPCS' CHECK (accreditation IN ('CPCS', 'NPORS', 'IPAF', 'ETC')),
  description text DEFAULT '',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view courses"
  ON courses FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Only admins can insert courses"
  ON courses FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

CREATE POLICY "Only admins can update courses"
  ON courses FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

CREATE POLICY "Only admins can delete courses"
  ON courses FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Course runs table
CREATE TABLE IF NOT EXISTS course_runs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  course_id uuid NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  start_date date NOT NULL,
  end_date date NOT NULL,
  location text NOT NULL,
  seats_total integer NOT NULL DEFAULT 8,
  seats_booked integer NOT NULL DEFAULT 0,
  trainer text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE course_runs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view course runs"
  ON course_runs FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Sales and admins can insert course runs"
  ON course_runs FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Sales and admins can update course runs"
  ON course_runs FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Only admins can delete course runs"
  ON course_runs FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Bookings table
CREATE TABLE IF NOT EXISTS bookings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  company_id uuid REFERENCES companies(id) ON DELETE SET NULL,
  contact_id uuid NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
  course_run_id uuid NOT NULL REFERENCES course_runs(id) ON DELETE CASCADE,
  status text DEFAULT 'reserved' CHECK (status IN ('reserved', 'confirmed', 'completed', 'cancelled')),
  amount decimal(10,2) NOT NULL DEFAULT 0,
  invoice_no text,
  certificate_no text,
  notes text DEFAULT '',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE bookings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view bookings"
  ON bookings FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Sales and admins can insert bookings"
  ON bookings FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Sales and admins can update bookings"
  ON bookings FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Only admins can delete bookings"
  ON bookings FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Tasks table
CREATE TABLE IF NOT EXISTS tasks (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title text NOT NULL,
  due_date date,
  related_to_type text CHECK (related_to_type IN ('lead', 'contact', 'booking', 'company')),
  related_to_id uuid,
  assigned_to uuid REFERENCES users(id) ON DELETE SET NULL,
  status text DEFAULT 'open' CHECK (status IN ('open', 'done')),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own tasks and admins can view all"
  ON tasks FOR SELECT
  TO authenticated
  USING (
    assigned_to = auth.uid() OR
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

CREATE POLICY "Sales and admins can insert tasks"
  ON tasks FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = auth.uid() 
      AND users.role IN ('admin', 'sales')
    )
  );

CREATE POLICY "Users can update their own tasks and admins can update all"
  ON tasks FOR UPDATE
  TO authenticated
  USING (
    assigned_to = auth.uid() OR
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  )
  WITH CHECK (
    assigned_to = auth.uid() OR
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

CREATE POLICY "Users can delete their own tasks and admins can delete all"
  ON tasks FOR DELETE
  TO authenticated
  USING (
    assigned_to = auth.uid() OR
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Activities table
CREATE TABLE IF NOT EXISTS activities (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_type text NOT NULL CHECK (entity_type IN ('lead', 'contact', 'booking', 'company')),
  entity_id uuid NOT NULL,
  activity_type text NOT NULL CHECK (activity_type IN ('created', 'updated', 'note', 'email', 'call')),
  description text NOT NULL,
  user_id uuid REFERENCES users(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now()
);

ALTER TABLE activities ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view activities"
  ON activities FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can insert activities"
  ON activities FOR INSERT
  TO authenticated
  WITH CHECK (true);

CREATE POLICY "Only admins can delete activities"
  ON activities FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_contacts_company ON contacts(company_id);
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_leads_assigned ON leads(assigned_to);
CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);
CREATE INDEX IF NOT EXISTS idx_course_runs_course ON course_runs(course_id);
CREATE INDEX IF NOT EXISTS idx_course_runs_dates ON course_runs(start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_bookings_contact ON bookings(contact_id);
CREATE INDEX IF NOT EXISTS idx_bookings_course_run ON bookings(course_run_id);
CREATE INDEX IF NOT EXISTS idx_bookings_status ON bookings(status);
CREATE INDEX IF NOT EXISTS idx_tasks_assigned ON tasks(assigned_to);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
CREATE INDEX IF NOT EXISTS idx_activities_entity ON activities(entity_type, entity_id);

-- Trigger to update updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_companies_updated_at') THEN
    CREATE TRIGGER update_companies_updated_at BEFORE UPDATE ON companies
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_contacts_updated_at') THEN
    CREATE TRIGGER update_contacts_updated_at BEFORE UPDATE ON contacts
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_leads_updated_at') THEN
    CREATE TRIGGER update_leads_updated_at BEFORE UPDATE ON leads
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_courses_updated_at') THEN
    CREATE TRIGGER update_courses_updated_at BEFORE UPDATE ON courses
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_course_runs_updated_at') THEN
    CREATE TRIGGER update_course_runs_updated_at BEFORE UPDATE ON course_runs
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_bookings_updated_at') THEN
    CREATE TRIGGER update_bookings_updated_at BEFORE UPDATE ON bookings
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
    CREATE TRIGGER update_tasks_updated_at BEFORE UPDATE ON tasks
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;
END $$;

-- ============================================
-- Migration: 20251021112345_fix_user_signup_policy.sql
-- ============================================

/*
  # Fix User Signup Policy
  
  1. Changes
    - Update the INSERT policy on users table to allow new users to create their own profile
    - The policy checks if the new user's ID matches the authenticated user's ID
    
  2. Security
    - Users can only insert their own profile (auth.uid() = NEW.id)
    - Admins can still insert any user profile
*/

-- Drop the old restrictive policy
DROP POLICY IF EXISTS "Only admins can insert users" ON users;

-- Create a new policy that allows users to insert their own profile during signup
CREATE POLICY "Users can insert their own profile during signup"
  ON users FOR INSERT
  TO authenticated
  WITH CHECK (
    auth.uid() = id OR
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- ============================================
-- Migration: 20251021155302_create_oauth_tokens_table.sql
-- ============================================

/*
  # Create OAuth Tokens Table

  1. New Tables
    - `oauth_tokens`
      - `id` (uuid, primary key) - Unique identifier for each token record
      - `user_id` (uuid, foreign key) - References auth.users, the user who owns this token
      - `provider` (text) - OAuth provider name (e.g., 'google')
      - `access_token` (text) - OAuth access token for API calls
      - `refresh_token` (text) - OAuth refresh token to renew access
      - `expires_at` (timestamptz) - When the access token expires
      - `scope` (text) - Granted OAuth scopes
      - `created_at` (timestamptz) - When this record was created
      - `updated_at` (timestamptz) - When this record was last updated

  2. Security
    - Enable RLS on `oauth_tokens` table
    - Add policy for users to read their own tokens
    - Add policy for users to insert their own tokens
    - Add policy for users to update their own tokens
    - Add policy for users to delete their own tokens

  3. Important Notes
    - Tokens are sensitive and should only be accessible by the owning user
    - The table uses cascading delete to clean up tokens when users are deleted
    - Created_at and updated_at timestamps track token lifecycle
*/

CREATE TABLE IF NOT EXISTS oauth_tokens (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  provider text NOT NULL,
  access_token text NOT NULL,
  refresh_token text,
  expires_at timestamptz NOT NULL,
  scope text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, provider)
);

ALTER TABLE oauth_tokens ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own oauth tokens"
  ON oauth_tokens
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own oauth tokens"
  ON oauth_tokens
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own oauth tokens"
  ON oauth_tokens
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own oauth tokens"
  ON oauth_tokens
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- ============================================
-- Migration: 20251022095915_add_email_message_id_to_leads.sql
-- ============================================

/*
  # Add email message ID tracking to leads

  1. Changes
    - Add `email_message_id` column to `leads` table to track imported emails
    - Add unique index to prevent duplicate imports
    - Column is nullable for manually created leads

  2. Purpose
    - Prevent duplicate lead creation when checking emails multiple times
    - Track which email message generated each lead
*/

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'leads' AND column_name = 'email_message_id'
  ) THEN
    ALTER TABLE leads ADD COLUMN email_message_id text;
  END IF;
END $$;

CREATE UNIQUE INDEX IF NOT EXISTS leads_email_message_id_unique 
  ON leads(email_message_id) 
  WHERE email_message_id IS NOT NULL;

-- ============================================
-- Migration: 20251022105211_create_training_sessions_table.sql
-- ============================================

/*
  # Create Training Sessions Table

  1. New Tables
    - `training_sessions`
      - `id` (uuid, primary key)
      - `title` (text) - Name of the training session
      - `description` (text, optional) - Details about the session
      - `start_date` (date) - Start date of the training
      - `end_date` (date) - End date of the training
      - `start_time` (time, optional) - Start time for the session
      - `end_time` (time, optional) - End time for the session
      - `color` (text) - Color code for display (e.g., 'blue', 'green', 'red')
      - `training_type` (text, optional) - Type of training (e.g., 'CPCS', 'NPORS')
      - `location` (text, optional) - Where the training takes place
      - `trainer_id` (uuid, optional) - Foreign key to users table
      - `capacity` (integer, optional) - Maximum number of participants
      - `enrolled_count` (integer, default 0) - Current number of enrolled participants
      - `status` (text, default 'scheduled') - Status: scheduled, in_progress, completed, cancelled
      - `notes` (text, optional) - Additional notes
      - `created_by` (uuid) - Foreign key to users table
      - `created_at` (timestamptz)
      - `updated_at` (timestamptz)

  2. Security
    - Enable RLS on `training_sessions` table
    - Add policy for authenticated users to view all training sessions
    - Add policy for authenticated users to create training sessions
    - Add policy for authenticated users to update their own training sessions
    - Add policy for authenticated users to delete their own training sessions
*/

CREATE TABLE IF NOT EXISTS training_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title text NOT NULL,
  description text,
  start_date date NOT NULL,
  end_date date NOT NULL,
  start_time time,
  end_time time,
  color text NOT NULL DEFAULT 'blue',
  training_type text,
  location text,
  trainer_id uuid REFERENCES users(id),
  capacity integer,
  enrolled_count integer DEFAULT 0,
  status text DEFAULT 'scheduled',
  notes text,
  created_by uuid REFERENCES users(id) NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE training_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view all training sessions"
  ON training_sessions
  FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can create training sessions"
  ON training_sessions
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Authenticated users can update training sessions"
  ON training_sessions
  FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Authenticated users can delete training sessions"
  ON training_sessions
  FOR DELETE
  TO authenticated
  USING (auth.uid() = created_by);

CREATE INDEX IF NOT EXISTS idx_training_sessions_dates ON training_sessions(start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_training_sessions_created_by ON training_sessions(created_by);

-- ============================================
-- Migration: 20251022110405_create_candidates_table.sql
-- ============================================

/*
  # Create Candidates Table

  1. New Tables
    - `candidates`
      - `id` (uuid, primary key)
      - `first_name` (text) - Candidate's first name
      - `last_name` (text) - Candidate's last name
      - `email` (text, unique) - Email address
      - `phone` (text) - Phone number
      - `date_of_birth` (date) - Date of birth
      - `address` (text) - Full address
      - `city` (text) - City
      - `postcode` (text) - Postcode
      - `national_insurance_number` (text) - NI number
      - `emergency_contact_name` (text) - Emergency contact name
      - `emergency_contact_phone` (text) - Emergency contact phone
      - `notes` (text) - Additional notes
      - `status` (text, default 'active') - Status: active, inactive, archived
      - `created_by` (uuid) - Foreign key to users table
      - `created_at` (timestamptz)
      - `updated_at` (timestamptz)

  2. Security
    - Enable RLS on `candidates` table
    - Add policy for authenticated users to view all candidates
    - Add policy for authenticated users to create candidates
    - Add policy for authenticated users to update candidates
    - Add policy for authenticated users to delete candidates
*/

CREATE TABLE IF NOT EXISTS candidates (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  first_name text NOT NULL,
  last_name text NOT NULL,
  email text UNIQUE,
  phone text,
  date_of_birth date,
  address text,
  city text,
  postcode text,
  national_insurance_number text,
  emergency_contact_name text,
  emergency_contact_phone text,
  notes text,
  status text DEFAULT 'active',
  created_by uuid REFERENCES users(id) NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE candidates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view all candidates"
  ON candidates
  FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can create candidates"
  ON candidates
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Authenticated users can update candidates"
  ON candidates
  FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Authenticated users can delete candidates"
  ON candidates
  FOR DELETE
  TO authenticated
  USING (true);

CREATE INDEX IF NOT EXISTS idx_candidates_email ON candidates(email);
CREATE INDEX IF NOT EXISTS idx_candidates_name ON candidates(last_name, first_name);
CREATE INDEX IF NOT EXISTS idx_candidates_status ON candidates(status);

-- ============================================
-- Migration: 20251022110428_create_candidate_files_and_courses_tables.sql
-- ============================================

/*
  # Create Candidate Files and Courses Tables

  1. New Tables
    - `candidate_files`
      - `id` (uuid, primary key)
      - `candidate_id` (uuid) - Foreign key to candidates table
      - `file_name` (text) - Original file name
      - `file_type` (text) - MIME type
      - `file_size` (integer) - File size in bytes
      - `file_url` (text) - URL to the file in storage
      - `storage_path` (text) - Path in Supabase storage
      - `description` (text) - Optional description
      - `uploaded_by` (uuid) - Foreign key to users table
      - `uploaded_at` (timestamptz)

    - `candidate_courses`
      - `id` (uuid, primary key)
      - `candidate_id` (uuid) - Foreign key to candidates table
      - `course_id` (uuid) - Foreign key to courses table
      - `training_session_id` (uuid, optional) - Foreign key to training_sessions table
      - `enrollment_date` (date) - When they enrolled
      - `completion_date` (date, optional) - When they completed
      - `status` (text, default 'enrolled') - Status: enrolled, in_progress, completed, failed, cancelled
      - `grade` (text, optional) - Grade received
      - `certificate_number` (text, optional) - Certificate number if issued
      - `notes` (text) - Additional notes
      - `created_by` (uuid) - Foreign key to users table
      - `created_at` (timestamptz)
      - `updated_at` (timestamptz)

  2. Security
    - Enable RLS on both tables
    - Add policies for authenticated users to manage files and course enrollments
*/

CREATE TABLE IF NOT EXISTS candidate_files (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  candidate_id uuid REFERENCES candidates(id) ON DELETE CASCADE NOT NULL,
  file_name text NOT NULL,
  file_type text NOT NULL,
  file_size integer NOT NULL,
  file_url text NOT NULL,
  storage_path text NOT NULL,
  description text,
  uploaded_by uuid REFERENCES users(id) NOT NULL,
  uploaded_at timestamptz DEFAULT now()
);

ALTER TABLE candidate_files ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view all candidate files"
  ON candidate_files
  FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can upload candidate files"
  ON candidate_files
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = uploaded_by);

CREATE POLICY "Authenticated users can delete candidate files"
  ON candidate_files
  FOR DELETE
  TO authenticated
  USING (true);

CREATE INDEX IF NOT EXISTS idx_candidate_files_candidate_id ON candidate_files(candidate_id);

CREATE TABLE IF NOT EXISTS candidate_courses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  candidate_id uuid REFERENCES candidates(id) ON DELETE CASCADE NOT NULL,
  course_id uuid REFERENCES courses(id) ON DELETE CASCADE NOT NULL,
  training_session_id uuid REFERENCES training_sessions(id) ON DELETE SET NULL,
  enrollment_date date NOT NULL DEFAULT CURRENT_DATE,
  completion_date date,
  status text DEFAULT 'enrolled',
  grade text,
  certificate_number text,
  notes text,
  created_by uuid REFERENCES users(id) NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE candidate_courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view all candidate courses"
  ON candidate_courses
  FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can create candidate courses"
  ON candidate_courses
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Authenticated users can update candidate courses"
  ON candidate_courses
  FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Authenticated users can delete candidate courses"
  ON candidate_courses
  FOR DELETE
  TO authenticated
  USING (true);

CREATE INDEX IF NOT EXISTS idx_candidate_courses_candidate_id ON candidate_courses(candidate_id);
CREATE INDEX IF NOT EXISTS idx_candidate_courses_course_id ON candidate_courses(course_id);
CREATE INDEX IF NOT EXISTS idx_candidate_courses_training_session_id ON candidate_courses(training_session_id);

-- ============================================
-- Migration: 20251022123144_add_account_manager_to_companies.sql
-- ============================================

/*
  # Add Account Manager to Companies

  1. Changes
    - Add `account_manager_id` column to `companies` table
    - Foreign key reference to `users` table
    - Allows tracking which user manages each company account

  2. Notes
    - Column is nullable to allow companies without assigned managers
    - Uses CASCADE to handle user deletions safely
*/

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'companies' AND column_name = 'account_manager_id'
  ) THEN
    ALTER TABLE companies ADD COLUMN account_manager_id uuid REFERENCES users(id) ON DELETE SET NULL;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_companies_account_manager_id ON companies(account_manager_id);

-- ============================================
-- Migration: 20251022154322_remove_course_fields_make_optional.sql
-- ============================================

/*
  # Remove Unnecessary Course Fields

  1. Changes
    - Remove `code` column from courses table (unique constraint and column)
    - Remove `category` column from courses table
    - Remove `accreditation` column from courses table
  
  2. Notes
    - These fields are being removed to simplify the course creation process
    - Course runs contain the scheduling information (dates, location, max candidates)
    - Using IF EXISTS to prevent errors if fields are already removed
*/

DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'courses' AND column_name = 'code'
  ) THEN
    ALTER TABLE courses DROP COLUMN code;
  END IF;

  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'courses' AND column_name = 'category'
  ) THEN
    ALTER TABLE courses DROP COLUMN category;
  END IF;

  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'courses' AND column_name = 'accreditation'
  ) THEN
    ALTER TABLE courses DROP COLUMN accreditation;
  END IF;
END $$;


-- ============================================
-- Migration: 20251023101031_add_multi_accreditation_support.sql
-- ============================================

/*
  # Add Multi-Accreditation Support to Courses

  ## Changes
  
  1. Courses Table
    - Change `accreditation` from single value to array of text
    - Remove `price_per_person` (will be moved to accreditation-specific pricing)
    - Add `available_accreditations` array field
  
  2. New Table: `course_accreditation_pricing`
    - Links courses to specific accreditation prices
    - Allows same course to have different prices for CPCS vs NPORS
  
  3. Bookings Table
    - Add `accreditation` field to track which accreditation the candidate is booking
    - Update amount calculation to use accreditation-specific pricing
  
  ## Usage
  
  - When creating a course, select multiple accreditations (e.g., CPCS and NPORS)
  - Set individual prices for each accreditation
  - When booking, candidate selects which accreditation they want
  - Price is automatically set based on selected accreditation
*/

-- Drop the existing check constraint on courses.accreditation
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'courses_accreditation_check' 
    AND table_name = 'courses'
  ) THEN
    ALTER TABLE courses DROP CONSTRAINT courses_accreditation_check;
  END IF;
END $$;

-- Change accreditation to array and make price_per_person nullable
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'courses' 
    AND column_name = 'accreditation'
    AND data_type != 'ARRAY'
  ) THEN
    ALTER TABLE courses 
      ALTER COLUMN accreditation DROP NOT NULL,
      ALTER COLUMN accreditation TYPE text[] USING ARRAY[accreditation],
      ALTER COLUMN accreditation SET DEFAULT ARRAY['CPCS']::text[];
  END IF;
  
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'courses' 
    AND column_name = 'price_per_person'
  ) THEN
    ALTER TABLE courses ALTER COLUMN price_per_person DROP NOT NULL;
  END IF;
END $$;

-- Create course_accreditation_pricing table
CREATE TABLE IF NOT EXISTS course_accreditation_pricing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  course_id uuid NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  accreditation text NOT NULL CHECK (accreditation IN ('CPCS', 'NPORS', 'IPAF', 'ETC')),
  price decimal(10,2) NOT NULL DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(course_id, accreditation)
);

ALTER TABLE course_accreditation_pricing ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view course pricing"
  ON course_accreditation_pricing FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Only admins can insert course pricing"
  ON course_accreditation_pricing FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

CREATE POLICY "Only admins can update course pricing"
  ON course_accreditation_pricing FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

CREATE POLICY "Only admins can delete course pricing"
  ON course_accreditation_pricing FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Add accreditation field to bookings
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'bookings' 
    AND column_name = 'accreditation'
  ) THEN
    ALTER TABLE bookings 
      ADD COLUMN accreditation text CHECK (accreditation IN ('CPCS', 'NPORS', 'IPAF', 'ETC'));
  END IF;
END $$;


-- ============================================
-- Migration: 20251023102254_add_accreditation_column_to_courses.sql
-- ============================================
