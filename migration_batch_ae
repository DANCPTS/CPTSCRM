-- Add invoice_sent field
ALTER TABLE bookings 
ADD COLUMN IF NOT EXISTS invoice_sent boolean DEFAULT false;

-- Add invoice_number field
ALTER TABLE bookings 
ADD COLUMN IF NOT EXISTS invoice_number text;

-- Add joining_instructions_sent field
ALTER TABLE bookings 
ADD COLUMN IF NOT EXISTS joining_instructions_sent boolean DEFAULT false;


-- ============================================
-- Migration: 20251103170412_fix_auto_create_candidates_course_run_lookup.sql
-- ============================================

/*
  # Fix auto-create candidates course run lookup

  1. Changes
    - Fix the course_run_id lookup to directly use the booking's lead_id
    - Previously was incorrectly looking up via company_id which doesn't exist in leads table
    - Simplify the logic to directly join bookings on lead_id

  2. Behavior
    - When a booking form is signed, the trigger will correctly find the course_run_id
    - from the booking that matches the lead_id
*/

CREATE OR REPLACE FUNCTION auto_create_candidates_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_delegate_names text;
  v_delegate_name text;
  v_first_name text;
  v_last_name text;
  v_contact_email text;
  v_contact_phone text;
  v_course_name text;
  v_course_id uuid;
  v_course_run_id uuid;
  v_candidate_id uuid;
  v_admin_user_id uuid;
  v_delegate_array text[];
  v_name_parts text[];
BEGIN
  -- Only trigger when status changes to 'signed'
  IF NEW.status = 'signed' AND (OLD.status IS NULL OR OLD.status != 'signed') THEN
    
    -- Get the first admin user to use as created_by
    SELECT id INTO v_admin_user_id FROM users WHERE role = 'admin' LIMIT 1;
    
    IF v_admin_user_id IS NULL THEN
      RAISE WARNING 'No admin user found, skipping candidate creation';
      RETURN NEW;
    END IF;
    
    -- Extract delegate names from form_data
    v_delegate_names := NEW.form_data->>'delegate_names';
    v_contact_email := NEW.form_data->>'contact_email';
    v_contact_phone := NEW.form_data->>'contact_phone';
    v_course_name := NEW.form_data->>'course_name';
    
    -- Find the course_id based on course name (try matching by title)
    IF v_course_name IS NOT NULL THEN
      SELECT id INTO v_course_id FROM courses WHERE title ILIKE '%' || v_course_name || '%' LIMIT 1;
    END IF;
    
    -- Try to find the course_run_id from the lead's booking directly
    IF NEW.lead_id IS NOT NULL THEN
      SELECT b.course_run_id INTO v_course_run_id
      FROM bookings b
      WHERE b.lead_id = NEW.lead_id
        AND b.course_run_id IS NOT NULL
      ORDER BY b.created_at DESC
      LIMIT 1;
    END IF;
    
    -- If no course_run found from booking, try to find an upcoming course run for the course
    IF v_course_run_id IS NULL AND v_course_id IS NOT NULL THEN
      SELECT id INTO v_course_run_id
      FROM course_runs
      WHERE course_id = v_course_id
        AND start_date >= CURRENT_DATE
      ORDER BY start_date ASC
      LIMIT 1;
    END IF;
    
    IF v_delegate_names IS NOT NULL AND v_delegate_names != '' THEN
      -- Split delegate names by newline
      v_delegate_array := string_to_array(v_delegate_names, E'\n');
      
      -- Process each delegate
      FOREACH v_delegate_name IN ARRAY v_delegate_array
      LOOP
        -- Trim whitespace
        v_delegate_name := trim(v_delegate_name);
        
        -- Skip empty lines
        IF v_delegate_name = '' THEN
          CONTINUE;
        END IF;
        
        -- Parse name into first and last name
        v_name_parts := string_to_array(v_delegate_name, ' ');
        
        IF array_length(v_name_parts, 1) >= 2 THEN
          v_first_name := v_name_parts[1];
          v_last_name := array_to_string(v_name_parts[2:array_length(v_name_parts, 1)], ' ');
        ELSE
          v_first_name := v_delegate_name;
          v_last_name := '';
        END IF;
        
        -- Check if candidate already exists by name (not email, since emails can be shared)
        SELECT id INTO v_candidate_id 
        FROM candidates 
        WHERE lower(first_name) = lower(v_first_name) 
          AND lower(last_name) = lower(v_last_name)
        LIMIT 1;
        
        -- Create candidate if doesn't exist
        IF v_candidate_id IS NULL THEN
          INSERT INTO candidates (
            first_name,
            last_name,
            email,
            phone,
            status,
            created_by
          ) VALUES (
            v_first_name,
            v_last_name,
            v_contact_email,
            v_contact_phone,
            'active',
            v_admin_user_id
          )
          RETURNING id INTO v_candidate_id;
          
          RAISE NOTICE 'Created candidate: % % (ID: %)', v_first_name, v_last_name, v_candidate_id;
        ELSE
          RAISE NOTICE 'Candidate already exists: % % (ID: %)', v_first_name, v_last_name, v_candidate_id;
        END IF;
        
        -- Link candidate to course run if found
        IF v_candidate_id IS NOT NULL AND v_course_run_id IS NOT NULL THEN
          -- Check if enrollment already exists for this course run
          IF NOT EXISTS (
            SELECT 1 FROM candidate_courses 
            WHERE candidate_id = v_candidate_id 
              AND course_run_id = v_course_run_id
          ) THEN
            INSERT INTO candidate_courses (
              candidate_id,
              course_id,
              course_run_id,
              enrollment_date,
              status,
              created_by
            ) VALUES (
              v_candidate_id,
              v_course_id,
              v_course_run_id,
              CURRENT_DATE,
              'enrolled',
              v_admin_user_id
            );
            
            RAISE NOTICE 'Enrolled candidate % in course run %', v_candidate_id, v_course_run_id;
          END IF;
        END IF;
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================
-- Migration: 20251104082819_create_notes_and_ai_extracted_data.sql
-- ============================================

/*
  # Create notes and AI extracted data tables

  1. New Tables
    - `notes`
      - Stores meeting notes, call notes, and other text entries
      - Links to leads, companies, candidates, or bookings
      - Tracks who created the note and when
      - Stores raw note content
      
    - `note_extractions`
      - Stores AI-extracted structured data from notes
      - Links back to the source note
      - Contains action items, dates, people, commitments
      - JSON field for flexible data structure

  2. Security
    - Enable RLS on both tables
    - Users can only access notes they created or are assigned to
    - Admin users can access all notes

  3. Features
    - Full text search on notes
    - Automatic timestamping
    - Support for multiple entity types (leads, companies, etc.)
*/

-- Create notes table
CREATE TABLE IF NOT EXISTS notes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Content
  content text NOT NULL,
  note_type text DEFAULT 'general' CHECK (note_type IN ('general', 'call', 'meeting', 'email', 'other')),
  
  -- Relationships (one of these should be set)
  lead_id uuid REFERENCES leads(id) ON DELETE CASCADE,
  company_id uuid REFERENCES companies(id) ON DELETE CASCADE,
  candidate_id uuid REFERENCES candidates(id) ON DELETE CASCADE,
  booking_id uuid REFERENCES bookings(id) ON DELETE CASCADE,
  
  -- Metadata
  created_by uuid REFERENCES users(id) NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  -- AI processing status
  ai_processed boolean DEFAULT false,
  ai_processed_at timestamptz
);

-- Create note_extractions table
CREATE TABLE IF NOT EXISTS note_extractions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  note_id uuid REFERENCES notes(id) ON DELETE CASCADE NOT NULL,
  
  -- Extracted data
  action_items jsonb DEFAULT '[]'::jsonb,
  dates jsonb DEFAULT '[]'::jsonb,
  people jsonb DEFAULT '[]'::jsonb,
  commitments jsonb DEFAULT '[]'::jsonb,
  sentiment text,
  priority text,
  suggested_status text,
  
  -- Additional extracted info
  extracted_data jsonb DEFAULT '{}'::jsonb,
  
  -- Metadata
  created_at timestamptz DEFAULT now() NOT NULL,
  model_used text,
  tokens_used integer
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_notes_lead_id ON notes(lead_id);
CREATE INDEX IF NOT EXISTS idx_notes_company_id ON notes(company_id);
CREATE INDEX IF NOT EXISTS idx_notes_candidate_id ON notes(candidate_id);
CREATE INDEX IF NOT EXISTS idx_notes_booking_id ON notes(booking_id);
CREATE INDEX IF NOT EXISTS idx_notes_created_by ON notes(created_by);
CREATE INDEX IF NOT EXISTS idx_notes_created_at ON notes(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_note_extractions_note_id ON note_extractions(note_id);

-- Enable full text search on notes
CREATE INDEX IF NOT EXISTS idx_notes_content_search ON notes USING gin(to_tsvector('english', content));

-- Enable RLS
ALTER TABLE notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE note_extractions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for notes
CREATE POLICY "Users can view notes they created"
  ON notes FOR SELECT
  TO authenticated
  USING (auth.uid() = created_by);

CREATE POLICY "Users can create notes"
  ON notes FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update their own notes"
  ON notes FOR UPDATE
  TO authenticated
  USING (auth.uid() = created_by)
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can delete their own notes"
  ON notes FOR DELETE
  TO authenticated
  USING (auth.uid() = created_by);

-- RLS Policies for note_extractions
CREATE POLICY "Users can view extractions for their notes"
  ON note_extractions FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM notes
      WHERE notes.id = note_extractions.note_id
      AND notes.created_by = auth.uid()
    )
  );

CREATE POLICY "Service role can insert extractions"
  ON note_extractions FOR INSERT
  TO authenticated
  WITH CHECK (true);

CREATE POLICY "Service role can update extractions"
  ON note_extractions FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_notes_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update updated_at
DROP TRIGGER IF EXISTS trigger_update_notes_updated_at ON notes;
CREATE TRIGGER trigger_update_notes_updated_at
  BEFORE UPDATE ON notes
  FOR EACH ROW
  EXECUTE FUNCTION update_notes_updated_at();


-- ============================================
-- Migration: 20251104093542_add_task_id_to_notes.sql
-- ============================================

/*
  # Add task_id column to notes table

  1. Changes
    - Add `task_id` column to `notes` table to support linking notes to tasks
    - Add foreign key constraint to ensure referential integrity
  
  2. Security
    - No changes to RLS policies needed - existing policies already cover notes access
*/

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'notes' AND column_name = 'task_id'
  ) THEN
    ALTER TABLE notes ADD COLUMN task_id uuid REFERENCES tasks(id) ON DELETE CASCADE;
  END IF;
END $$;

-- ============================================
-- Migration: 20251104135240_add_pass_fail_status_to_candidate_courses.sql
-- ============================================

/*
  # Add Pass/Fail Status to Candidate Courses

  1. Changes
    - Add `result` column to `candidate_courses` table
      - Options: 'pending', 'passed', 'failed'
      - Default: 'pending'
    - This provides an explicit field to track whether a candidate passed or failed their course
    - Works alongside the existing `status` field which tracks enrollment/completion status

  2. Notes
    - Existing records will default to 'pending'
    - The `status` field tracks the enrollment state (enrolled, in_progress, completed, cancelled)
    - The new `result` field tracks the pass/fail outcome
*/

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'candidate_courses' AND column_name = 'result'
  ) THEN
    ALTER TABLE candidate_courses ADD COLUMN result text DEFAULT 'pending';
  END IF;
END $$;

-- ============================================
-- Migration: 20251104144556_update_seats_booked_on_candidate_courses_change.sql
-- ============================================

/*
  # Update seats_booked when candidate_courses changes

  1. Changes
    - Create trigger function to update seats_booked in course_runs table when candidate_courses records are inserted/deleted
    - This ensures the calendar shows accurate enrollment counts

  2. Notes
    - When a candidate_courses record is inserted, increment seats_booked
    - When a candidate_courses record is deleted, decrement seats_booked
    - Only affects course_runs that have a matching course_run_id
*/

-- Function to update seats_booked count based on candidate_courses changes
CREATE OR REPLACE FUNCTION update_seats_booked_from_candidate_courses()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Increment seats_booked when a candidate enrolls
    IF NEW.course_run_id IS NOT NULL THEN
      UPDATE course_runs
      SET seats_booked = COALESCE(seats_booked, 0) + 1
      WHERE id = NEW.course_run_id;
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    -- Decrement seats_booked when a candidate is removed
    IF OLD.course_run_id IS NOT NULL THEN
      UPDATE course_runs
      SET seats_booked = GREATEST(COALESCE(seats_booked, 0) - 1, 0)
      WHERE id = OLD.course_run_id;
    END IF;
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Handle course_run_id changes
    IF OLD.course_run_id IS NOT NULL AND OLD.course_run_id != NEW.course_run_id THEN
      -- Decrement from old course run
      UPDATE course_runs
      SET seats_booked = GREATEST(COALESCE(seats_booked, 0) - 1, 0)
      WHERE id = OLD.course_run_id;
    END IF;
    
    IF NEW.course_run_id IS NOT NULL AND OLD.course_run_id != NEW.course_run_id THEN
      -- Increment on new course run
      UPDATE course_runs
      SET seats_booked = COALESCE(seats_booked, 0) + 1
      WHERE id = NEW.course_run_id;
    END IF;
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Create trigger on candidate_courses
DROP TRIGGER IF EXISTS update_seats_booked_candidate_courses_trigger ON candidate_courses;
CREATE TRIGGER update_seats_booked_candidate_courses_trigger
  AFTER INSERT OR UPDATE OR DELETE ON candidate_courses
  FOR EACH ROW
  EXECUTE FUNCTION update_seats_booked_from_candidate_courses();

-- ============================================
-- Migration: 20251104144822_add_training_and_test_days_to_course_runs.sql
-- ============================================

/*
  # Add Training and Test Days to Course Runs

  1. New Columns
    - `training_days` (date[]) - Array of training days for the course
    - `test_days` (date[]) - Array of test/assessment days for the course

  2. Changes
    - Add training_days column to course_runs table
    - Add test_days column to course_runs table
    - These allow flexible scheduling where training days show as green and test days show as red on the calendar

  3. Notes
    - start_date and end_date remain for overall course duration
    - training_days and test_days provide granular day-by-day control
    - If arrays are empty, falls back to showing the entire date range
*/

-- Add training_days and test_days columns to course_runs
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'course_runs' AND column_name = 'training_days'
  ) THEN
    ALTER TABLE course_runs ADD COLUMN training_days date[] DEFAULT '{}';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'course_runs' AND column_name = 'test_days'
  ) THEN
    ALTER TABLE course_runs ADD COLUMN test_days date[] DEFAULT '{}';
  END IF;
END $$;

-- ============================================
-- Migration: 20251104150000_create_attendance_table.sql
-- ============================================

/*
  # Create Attendance Tracking Table

  1. New Tables
    - `attendance`
      - `id` (uuid, primary key)
      - `candidate_course_id` (uuid, references candidate_courses)
      - `date` (date) - the specific date of attendance
      - `status` (text) - present, absent, late, excused
      - `notes` (text) - optional notes about attendance
      - `marked_by` (uuid, references users) - who marked the attendance
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `attendance` table
    - Add policies for authenticated users to manage attendance
    - Only authenticated users can view and mark attendance

  3. Indexes
    - Index on candidate_course_id for fast lookups
    - Index on date for filtering by date range
*/

CREATE TABLE IF NOT EXISTS attendance (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  candidate_course_id uuid REFERENCES candidate_courses(id) ON DELETE CASCADE NOT NULL,
  date date NOT NULL,
  status text NOT NULL CHECK (status IN ('present', 'absent', 'late', 'excused')),
  notes text,
  marked_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(candidate_course_id, date)
);

CREATE INDEX IF NOT EXISTS idx_attendance_candidate_course ON attendance(candidate_course_id);
CREATE INDEX IF NOT EXISTS idx_attendance_date ON attendance(date);

ALTER TABLE attendance ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view attendance"
  ON attendance FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can mark attendance"
  ON attendance FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = marked_by);

CREATE POLICY "Authenticated users can update attendance"
  ON attendance FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (auth.uid() = marked_by);

CREATE POLICY "Authenticated users can delete attendance"
  ON attendance FOR DELETE
  TO authenticated
  USING (true);


-- ============================================
-- Migration: 20251104151418_20251104150000_create_attendance_table.sql
-- ============================================

/*
  # Create Attendance Tracking Table

  1. New Tables
    - `attendance`
      - `id` (uuid, primary key)
      - `candidate_course_id` (uuid, references candidate_courses)
      - `date` (date) - the specific date of attendance
      - `status` (text) - present, absent, late, excused
      - `notes` (text) - optional notes about attendance
      - `marked_by` (uuid, references users) - who marked the attendance
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `attendance` table
    - Add policies for authenticated users to manage attendance
    - Only authenticated users can view and mark attendance

  3. Indexes
    - Index on candidate_course_id for fast lookups
    - Index on date for filtering by date range
*/

CREATE TABLE IF NOT EXISTS attendance (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  candidate_course_id uuid REFERENCES candidate_courses(id) ON DELETE CASCADE NOT NULL,
  date date NOT NULL,
  status text NOT NULL CHECK (status IN ('present', 'absent', 'late', 'excused')),
  notes text,
  marked_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(candidate_course_id, date)
);

CREATE INDEX IF NOT EXISTS idx_attendance_candidate_course ON attendance(candidate_course_id);
CREATE INDEX IF NOT EXISTS idx_attendance_date ON attendance(date);

ALTER TABLE attendance ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view attendance"
  ON attendance FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can mark attendance"
  ON attendance FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = marked_by);

CREATE POLICY "Authenticated users can update attendance"
  ON attendance FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (auth.uid() = marked_by);

CREATE POLICY "Authenticated users can delete attendance"
  ON attendance FOR DELETE
  TO authenticated
  USING (true);


-- ============================================
-- Migration: 20251104151418_20251104160000_add_candidate_to_bookings_and_auto_enroll.sql
-- ============================================

/*
  # Fix Auto-Enrollment Trigger to Include created_by

  1. Changes
    - Update auto_enroll_candidate_from_booking function to include created_by field
    - Uses auth.uid() if available, otherwise uses a system user
    - Fixes the constraint violation error

  2. Security
    - Maintains existing RLS policies
*/

-- Update the function to include created_by
CREATE OR REPLACE FUNCTION auto_enroll_candidate_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_course_id uuid;
  v_created_by uuid;
BEGIN
  -- Only process if there's a candidate_id
  IF NEW.candidate_id IS NOT NULL THEN
    -- Get the course_id from the course_run
    SELECT course_id INTO v_course_id
    FROM course_runs
    WHERE id = NEW.course_run_id;

    IF v_course_id IS NOT NULL THEN
      -- Check if candidate is already enrolled in this course run
      IF NOT EXISTS (
        SELECT 1 FROM candidate_courses
        WHERE candidate_id = NEW.candidate_id
        AND course_id = v_course_id
        AND course_run_id = NEW.course_run_id
      ) THEN
        -- Get created_by: use auth.uid() if available, otherwise use first admin user
        v_created_by := auth.uid();
        IF v_created_by IS NULL THEN
          SELECT id INTO v_created_by FROM users LIMIT 1;
        END IF;

        -- Enroll the candidate
        INSERT INTO candidate_courses (
          candidate_id,
          course_id,
          course_run_id,
          enrollment_date,
          status,
          created_by
        ) VALUES (
          NEW.candidate_id,
          v_course_id,
          NEW.course_run_id,
          NOW(),
          'enrolled',
          v_created_by
        );

        RAISE NOTICE 'Auto-enrolled candidate % in course % (run: %)', NEW.candidate_id, v_course_id, NEW.course_run_id;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================
-- Migration: 20251104152427_20251104160000_add_candidate_to_bookings_and_auto_enroll.sql
-- ============================================

/*
  # Add Candidate Reference to Bookings and Auto-Enrollment

  1. Changes
    - Add `candidate_id` column to `bookings` table to track which candidate a booking is for
    - Create trigger to automatically enroll candidates in courses when a booking is created
    - This ensures that individual bookings (from candidates) automatically appear in the candidate's enrolled courses

  2. Security
    - Maintains existing RLS policies
    - Adds foreign key constraint with CASCADE delete
*/

-- Add candidate_id column to bookings table
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'bookings' AND column_name = 'candidate_id'
  ) THEN
    ALTER TABLE bookings ADD COLUMN candidate_id uuid REFERENCES candidates(id) ON DELETE CASCADE;
    CREATE INDEX IF NOT EXISTS idx_bookings_candidate_id ON bookings(candidate_id);
  END IF;
END $$;

-- Create function to auto-enroll candidate when booking is created
CREATE OR REPLACE FUNCTION auto_enroll_candidate_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_course_id uuid;
BEGIN
  -- Only process if there's a candidate_id
  IF NEW.candidate_id IS NOT NULL THEN
    -- Get the course_id from the course_run
    SELECT course_id INTO v_course_id
    FROM course_runs
    WHERE id = NEW.course_run_id;

    IF v_course_id IS NOT NULL THEN
      -- Check if candidate is already enrolled in this course run
      IF NOT EXISTS (
        SELECT 1 FROM candidate_courses
        WHERE candidate_id = NEW.candidate_id
        AND course_id = v_course_id
        AND course_run_id = NEW.course_run_id
      ) THEN
        -- Enroll the candidate
        INSERT INTO candidate_courses (
          candidate_id,
          course_id,
          course_run_id,
          enrollment_date,
          status
        ) VALUES (
          NEW.candidate_id,
          v_course_id,
          NEW.course_run_id,
          NOW(),
          'enrolled'
        );

        RAISE NOTICE 'Auto-enrolled candidate % in course % (run: %)', NEW.candidate_id, v_course_id, NEW.course_run_id;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS trigger_auto_enroll_candidate_from_booking ON bookings;
CREATE TRIGGER trigger_auto_enroll_candidate_from_booking
  AFTER INSERT ON bookings
  FOR EACH ROW
  EXECUTE FUNCTION auto_enroll_candidate_from_booking();


-- ============================================
-- Migration: 20251104152912_20251104170000_link_existing_bookings_to_candidates.sql
-- ============================================

/*
  # Link Existing Bookings to Candidates

  1. Purpose
    - Find existing bookings that match candidates by email, phone, or name
    - Update those bookings with the correct candidate_id
    - The existing trigger will then auto-enroll those candidates in their courses

  2. Matching Logic
    - First tries to match by email (most reliable)
    - Then tries to match by phone
    - Finally tries to match by first name + last name combination
    - Only matches where company_id is NULL (individual bookings)

  3. Process
    - Updates bookings table with candidate_id where matches found
    - The auto_enroll_candidate_from_booking trigger will NOT fire on UPDATE
    - So we manually create the enrollments for matched bookings
*/

-- First, let's link bookings to candidates based on matching contact information
DO $$
DECLARE
  v_booking RECORD;
  v_candidate_id uuid;
  v_contact RECORD;
  v_course_id uuid;
  v_enrolled_count integer := 0;
BEGIN
  -- Loop through all bookings that don't have a candidate_id and have no company (individual bookings)
  FOR v_booking IN
    SELECT b.id, b.contact_id, b.course_run_id
    FROM bookings b
    WHERE b.candidate_id IS NULL
    AND b.company_id IS NULL
  LOOP
    -- Get contact info
    SELECT * INTO v_contact
    FROM contacts
    WHERE id = v_booking.contact_id;

    IF v_contact IS NOT NULL THEN
      v_candidate_id := NULL;

      -- Try to match by email (most reliable)
      IF v_contact.email IS NOT NULL AND v_contact.email != '' THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE LOWER(email) = LOWER(v_contact.email)
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If no match by email, try by phone
      IF v_candidate_id IS NULL AND v_contact.phone IS NOT NULL AND v_contact.phone != '' THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE phone = v_contact.phone
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If no match by phone, try by name combination
      IF v_candidate_id IS NULL AND v_contact.first_name IS NOT NULL AND v_contact.last_name IS NOT NULL THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE LOWER(first_name) = LOWER(v_contact.first_name)
        AND LOWER(last_name) = LOWER(v_contact.last_name)
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If we found a matching candidate, update the booking and enroll them
      IF v_candidate_id IS NOT NULL THEN
        -- Update the booking with candidate_id
        UPDATE bookings
        SET candidate_id = v_candidate_id
        WHERE id = v_booking.id;

        -- Get the course_id from course_run
        SELECT course_id INTO v_course_id
        FROM course_runs
        WHERE id = v_booking.course_run_id;

        -- Enroll the candidate if not already enrolled
        IF v_course_id IS NOT NULL THEN
          IF NOT EXISTS (
            SELECT 1 FROM candidate_courses
            WHERE candidate_id = v_candidate_id
            AND course_id = v_course_id
            AND course_run_id = v_booking.course_run_id
          ) THEN
            INSERT INTO candidate_courses (
              candidate_id,
              course_id,
              course_run_id,
              enrollment_date,
              status
            ) VALUES (
              v_candidate_id,
              v_course_id,
              v_booking.course_run_id,
              NOW(),
              'enrolled'
            );

            v_enrolled_count := v_enrolled_count + 1;
            RAISE NOTICE 'Linked and enrolled candidate % in course % (booking: %)', v_candidate_id, v_course_id, v_booking.id;
          END IF;
        END IF;
      END IF;
    END IF;
  END LOOP;

  RAISE NOTICE 'Migration complete: Linked and enrolled % candidates from existing bookings', v_enrolled_count;
END $$;


-- ============================================
-- Migration: 20251104153250_20251104151418_fix_auto_enroll_trigger.sql
-- ============================================

/*
  # Fix Auto-Enrollment Trigger to Include created_by

  1. Changes
    - Update auto_enroll_candidate_from_booking function to include created_by field
    - Uses auth.uid() if available, otherwise uses a system user
    - Fixes the constraint violation error

  2. Security
    - Maintains existing RLS policies
*/

-- Update the function to include created_by
CREATE OR REPLACE FUNCTION auto_enroll_candidate_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_course_id uuid;
  v_created_by uuid;
BEGIN
  -- Only process if there's a candidate_id
  IF NEW.candidate_id IS NOT NULL THEN
    -- Get the course_id from the course_run
    SELECT course_id INTO v_course_id
    FROM course_runs
    WHERE id = NEW.course_run_id;

    IF v_course_id IS NOT NULL THEN
      -- Check if candidate is already enrolled in this course run
      IF NOT EXISTS (
        SELECT 1 FROM candidate_courses
        WHERE candidate_id = NEW.candidate_id
        AND course_id = v_course_id
        AND course_run_id = NEW.course_run_id
      ) THEN
        -- Get created_by: use auth.uid() if available, otherwise use first admin user
        v_created_by := auth.uid();
        IF v_created_by IS NULL THEN
          SELECT id INTO v_created_by FROM users LIMIT 1;
        END IF;

        -- Enroll the candidate
        INSERT INTO candidate_courses (
          candidate_id,
          course_id,
          course_run_id,
          enrollment_date,
          status,
          created_by
        ) VALUES (
          NEW.candidate_id,
          v_course_id,
          NEW.course_run_id,
          NOW(),
          'enrolled',
          v_created_by
        );

        RAISE NOTICE 'Auto-enrolled candidate % in course % (run: %)', NEW.candidate_id, v_course_id, NEW.course_run_id;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================
-- Migration: 20251104153326_20251104152912_link_existing_bookings_fixed.sql
-- ============================================

/*
  # Link Existing Bookings to Candidates (Fixed with created_by)

  1. Purpose
    - Find existing bookings that match candidates by email, phone, or name
    - Update those bookings with the correct candidate_id
    - Enroll candidates in their courses with proper created_by field

  2. Matching Logic
    - First tries to match by email (most reliable)
    - Then tries to match by phone
    - Finally tries to match by first name + last name combination
    - Only matches where company_id is NULL (individual bookings)

  3. Process
    - Updates bookings table with candidate_id where matches found
    - Creates candidate_courses enrollments with proper created_by
*/

