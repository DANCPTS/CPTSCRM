-- Link bookings to candidates based on matching contact information
DO $$
DECLARE
  v_booking RECORD;
  v_candidate_id uuid;
  v_contact RECORD;
  v_course_id uuid;
  v_enrolled_count integer := 0;
  v_created_by uuid;
BEGIN
  -- Get a user ID to use as created_by
  SELECT id INTO v_created_by FROM users LIMIT 1;

  -- Loop through all bookings that don't have a candidate_id and have no company (individual bookings)
  FOR v_booking IN
    SELECT b.id, b.contact_id, b.course_run_id
    FROM bookings b
    WHERE b.candidate_id IS NULL
    AND b.company_id IS NULL
  LOOP
    -- Get contact info
    SELECT * INTO v_contact
    FROM contacts
    WHERE id = v_booking.contact_id;

    IF v_contact IS NOT NULL THEN
      v_candidate_id := NULL;

      -- Try to match by email (most reliable)
      IF v_contact.email IS NOT NULL AND v_contact.email != '' THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE LOWER(email) = LOWER(v_contact.email)
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If no match by email, try by phone
      IF v_candidate_id IS NULL AND v_contact.phone IS NOT NULL AND v_contact.phone != '' THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE phone = v_contact.phone
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If no match by phone, try by name combination
      IF v_candidate_id IS NULL AND v_contact.first_name IS NOT NULL AND v_contact.last_name IS NOT NULL THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE LOWER(first_name) = LOWER(v_contact.first_name)
        AND LOWER(last_name) = LOWER(v_contact.last_name)
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If we found a matching candidate, update the booking and enroll them
      IF v_candidate_id IS NOT NULL THEN
        -- Update the booking with candidate_id
        UPDATE bookings
        SET candidate_id = v_candidate_id
        WHERE id = v_booking.id;

        -- Get the course_id from course_run
        SELECT course_id INTO v_course_id
        FROM course_runs
        WHERE id = v_booking.course_run_id;

        -- Enroll the candidate if not already enrolled
        IF v_course_id IS NOT NULL THEN
          IF NOT EXISTS (
            SELECT 1 FROM candidate_courses
            WHERE candidate_id = v_candidate_id
            AND course_id = v_course_id
            AND course_run_id = v_booking.course_run_id
          ) THEN
            INSERT INTO candidate_courses (
              candidate_id,
              course_id,
              course_run_id,
              enrollment_date,
              status,
              created_by
            ) VALUES (
              v_candidate_id,
              v_course_id,
              v_booking.course_run_id,
              NOW(),
              'enrolled',
              v_created_by
            );

            v_enrolled_count := v_enrolled_count + 1;
            RAISE NOTICE 'Linked and enrolled candidate % in course % (booking: %)', v_candidate_id, v_course_id, v_booking.id;
          END IF;
        END IF;
      END IF;
    END IF;
  END LOOP;

  RAISE NOTICE 'Migration complete: Linked and enrolled % candidates from existing bookings', v_enrolled_count;
END $$;


-- ============================================
-- Migration: 20251104153712_20251104180000_fix_attendance_rls_policies.sql
-- ============================================

/*
  # Fix Attendance RLS Policies

  1. Changes
    - Remove restrictive WITH CHECK from INSERT policy
    - Remove restrictive WITH CHECK from UPDATE policy
    - Allow any authenticated user to mark and update attendance
    - Keep the marked_by field for audit purposes but don't restrict based on it

  2. Security
    - All authenticated users can mark attendance (they're all staff members)
    - Maintains audit trail with marked_by field
*/

-- Drop existing policies
DROP POLICY IF EXISTS "Authenticated users can mark attendance" ON attendance;
DROP POLICY IF EXISTS "Authenticated users can update attendance" ON attendance;

-- Create new policies without restrictive WITH CHECK
CREATE POLICY "Authenticated users can mark attendance"
  ON attendance
  FOR INSERT
  TO authenticated
  WITH CHECK (true);

CREATE POLICY "Authenticated users can update attendance"
  ON attendance
  FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);


-- ============================================
-- Migration: 20251104155208_fix_seats_booked_double_counting.sql
-- ============================================

/*
  # Fix seats_booked double counting issue

  1. Changes
    - Drop the booking-based seats_booked trigger (obsolete now that we have candidate_courses trigger)
    - Recalculate seats_booked based on actual candidate_courses count
    
  2. Why
    - Currently both bookings AND candidate_courses triggers update seats_booked
    - This causes double-counting when a booking creates a candidate_course
    - candidate_courses is the source of truth for enrollment
*/

-- Drop the old booking-based trigger
DROP TRIGGER IF EXISTS update_seats_booked_trigger ON bookings;
DROP FUNCTION IF EXISTS update_seats_booked();

-- Recalculate seats_booked for all course runs based on actual enrolled candidates
UPDATE course_runs cr
SET seats_booked = (
  SELECT COUNT(*)
  FROM candidate_courses cc
  WHERE cc.course_run_id = cr.id
  AND cc.status = 'enrolled'
);


-- ============================================
-- Migration: 20251104160000_add_candidate_to_bookings_and_auto_enroll.sql
-- ============================================

/*
  # Add Candidate Reference to Bookings and Auto-Enrollment

  1. Changes
    - Add `candidate_id` column to `bookings` table to track which candidate a booking is for
    - Create trigger to automatically enroll candidates in courses when a booking is created
    - This ensures that individual bookings (from candidates) automatically appear in the candidate's enrolled courses

  2. Security
    - Maintains existing RLS policies
    - Adds foreign key constraint with CASCADE delete
*/

-- Add candidate_id column to bookings table
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'bookings' AND column_name = 'candidate_id'
  ) THEN
    ALTER TABLE bookings ADD COLUMN candidate_id uuid REFERENCES candidates(id) ON DELETE CASCADE;
    CREATE INDEX IF NOT EXISTS idx_bookings_candidate_id ON bookings(candidate_id);
  END IF;
END $$;

-- Create function to auto-enroll candidate when booking is created
CREATE OR REPLACE FUNCTION auto_enroll_candidate_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_course_id uuid;
BEGIN
  -- Only process if there's a candidate_id
  IF NEW.candidate_id IS NOT NULL THEN
    -- Get the course_id from the course_run
    SELECT course_id INTO v_course_id
    FROM course_runs
    WHERE id = NEW.course_run_id;

    IF v_course_id IS NOT NULL THEN
      -- Check if candidate is already enrolled in this course run
      IF NOT EXISTS (
        SELECT 1 FROM candidate_courses
        WHERE candidate_id = NEW.candidate_id
        AND course_id = v_course_id
        AND course_run_id = NEW.course_run_id
      ) THEN
        -- Enroll the candidate
        INSERT INTO candidate_courses (
          candidate_id,
          course_id,
          course_run_id,
          enrollment_date,
          status
        ) VALUES (
          NEW.candidate_id,
          v_course_id,
          NEW.course_run_id,
          NOW(),
          'enrolled'
        );

        RAISE NOTICE 'Auto-enrolled candidate % in course % (run: %)', NEW.candidate_id, v_course_id, NEW.course_run_id;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS trigger_auto_enroll_candidate_from_booking ON bookings;
CREATE TRIGGER trigger_auto_enroll_candidate_from_booking
  AFTER INSERT ON bookings
  FOR EACH ROW
  EXECUTE FUNCTION auto_enroll_candidate_from_booking();


-- ============================================
-- Migration: 20251104170000_link_existing_bookings_to_candidates.sql
-- ============================================

/*
  # Link Existing Bookings to Candidates

  1. Purpose
    - Find existing bookings that match candidates by email, phone, or name
    - Update those bookings with the correct candidate_id
    - The existing trigger will then auto-enroll those candidates in their courses

  2. Matching Logic
    - First tries to match by email (most reliable)
    - Then tries to match by phone
    - Finally tries to match by first name + last name combination
    - Only matches where company_id is NULL (individual bookings)

  3. Process
    - Updates bookings table with candidate_id where matches found
    - The auto_enroll_candidate_from_booking trigger will NOT fire on UPDATE
    - So we manually create the enrollments for matched bookings
*/

-- First, let's link bookings to candidates based on matching contact information
DO $$
DECLARE
  v_booking RECORD;
  v_candidate_id uuid;
  v_contact RECORD;
  v_course_id uuid;
  v_enrolled_count integer := 0;
BEGIN
  -- Loop through all bookings that don't have a candidate_id and have no company (individual bookings)
  FOR v_booking IN
    SELECT b.id, b.contact_id, b.course_run_id
    FROM bookings b
    WHERE b.candidate_id IS NULL
    AND b.company_id IS NULL
  LOOP
    -- Get contact info
    SELECT * INTO v_contact
    FROM contacts
    WHERE id = v_booking.contact_id;

    IF v_contact IS NOT NULL THEN
      v_candidate_id := NULL;

      -- Try to match by email (most reliable)
      IF v_contact.email IS NOT NULL AND v_contact.email != '' THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE LOWER(email) = LOWER(v_contact.email)
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If no match by email, try by phone
      IF v_candidate_id IS NULL AND v_contact.phone IS NOT NULL AND v_contact.phone != '' THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE phone = v_contact.phone
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If no match by phone, try by name combination
      IF v_candidate_id IS NULL AND v_contact.first_name IS NOT NULL AND v_contact.last_name IS NOT NULL THEN
        SELECT id INTO v_candidate_id
        FROM candidates
        WHERE LOWER(first_name) = LOWER(v_contact.first_name)
        AND LOWER(last_name) = LOWER(v_contact.last_name)
        AND status = 'active'
        LIMIT 1;
      END IF;

      -- If we found a matching candidate, update the booking and enroll them
      IF v_candidate_id IS NOT NULL THEN
        -- Update the booking with candidate_id
        UPDATE bookings
        SET candidate_id = v_candidate_id
        WHERE id = v_booking.id;

        -- Get the course_id from course_run
        SELECT course_id INTO v_course_id
        FROM course_runs
        WHERE id = v_booking.course_run_id;

        -- Enroll the candidate if not already enrolled
        IF v_course_id IS NOT NULL THEN
          IF NOT EXISTS (
            SELECT 1 FROM candidate_courses
            WHERE candidate_id = v_candidate_id
            AND course_id = v_course_id
            AND course_run_id = v_booking.course_run_id
          ) THEN
            INSERT INTO candidate_courses (
              candidate_id,
              course_id,
              course_run_id,
              enrollment_date,
              status
            ) VALUES (
              v_candidate_id,
              v_course_id,
              v_booking.course_run_id,
              NOW(),
              'enrolled'
            );

            v_enrolled_count := v_enrolled_count + 1;
            RAISE NOTICE 'Linked and enrolled candidate % in course % (booking: %)', v_candidate_id, v_course_id, v_booking.id;
          END IF;
        END IF;
      END IF;
    END IF;
  END LOOP;

  RAISE NOTICE 'Migration complete: Linked and enrolled % candidates from existing bookings', v_enrolled_count;
END $$;


-- ============================================
-- Migration: 20251105111934_add_email_source_to_leads.sql
-- ============================================

/*
  # Add Email Source to Leads

  1. Changes
    - Update leads table source constraint to include 'email' option
    - This allows tracking leads from email imports separately from website/Google Ads leads
  
  2. Purpose
    - Differentiate email-imported leads from website leads
    - Enable separate statistics for email vs website lead performance
    - Track conversion rates for different lead sources
*/

-- Drop the existing constraint
ALTER TABLE leads DROP CONSTRAINT IF EXISTS leads_source_check;

-- Add new constraint with 'email' included
ALTER TABLE leads ADD CONSTRAINT leads_source_check 
  CHECK (source IN ('web', 'email', 'phone', 'referral'));


-- ============================================
-- Migration: 20251105114843_add_manual_source_to_leads.sql
-- ============================================

/*
  # Add Manual Source to Leads

  1. Changes
    - Update leads table source constraint to include 'manual' option
    - This allows tracking manually-entered leads separately from email-imported leads
  
  2. Purpose
    - Differentiate manual leads (entered through UI) from email leads (imported via email button)
    - Enable separate statistics for email vs manual lead performance
    - Track conversion rates for different lead entry methods
*/

-- Drop the existing constraint
ALTER TABLE leads DROP CONSTRAINT IF EXISTS leads_source_check;

-- Add new constraint with 'manual' included
ALTER TABLE leads ADD CONSTRAINT leads_source_check 
  CHECK (source IN ('web', 'email', 'manual', 'phone', 'referral'));


-- ============================================
-- Migration: 20251105115617_add_email_import_source.sql
-- ============================================

/*
  # Add Email Import Source

  1. Changes
    - Update leads table source constraint to include 'email_import' option
    - This separates email-imported leads (Google Ads) from manual email leads
  
  2. Purpose
    - 'email_import' = leads from email upload button (Google Ads) → email statistics
    - 'email', 'phone', 'referral' = manually entered leads → manual statistics
*/

-- Drop the existing constraint
ALTER TABLE leads DROP CONSTRAINT IF EXISTS leads_source_check;

-- Add new constraint with 'email_import' included
ALTER TABLE leads ADD CONSTRAINT leads_source_check 
  CHECK (source IN ('email_import', 'email', 'phone', 'referral', 'web', 'manual'));


-- ============================================
-- Migration: 20251105122356_add_invoice_tracking_to_booking_forms.sql
-- ============================================

/*
  # Add invoice tracking to booking forms

  1. Changes
    - Add invoice_sent boolean to booking_forms table to track invoice status
    - Add invoice_number text to booking_forms table to store invoice reference
    - Default invoice_sent to false

  2. Notes
    - This allows tracking invoices before a booking is created
    - Ensures the workflow: Sign Form → Send Invoice → Create Booking
*/

ALTER TABLE booking_forms 
ADD COLUMN IF NOT EXISTS invoice_sent boolean DEFAULT false;

ALTER TABLE booking_forms 
ADD COLUMN IF NOT EXISTS invoice_number text;


-- ============================================
-- Migration: 20251105123634_add_authenticated_update_policy_for_booking_forms.sql
-- ============================================

/*
  # Add authenticated user update policy for booking forms

  1. Changes
    - Add UPDATE policy for authenticated admin/sales users to update booking forms
    - This allows staff to update invoice details and other fields

  2. Security
    - Only authenticated users with admin or sales role can update
    - This matches the existing SELECT and INSERT policies
*/

CREATE POLICY "Authenticated users can update booking forms"
  ON booking_forms
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role IN ('admin', 'sales')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role IN ('admin', 'sales')
    )
  );


-- ============================================
-- Migration: 20251106103543_create_marketing_campaigns_and_templates.sql
-- ============================================

/*
  # Create Marketing Campaigns and Email Templates

  1. New Tables
    - `email_templates`
      - `id` (uuid, primary key)
      - `name` (text) - Template name
      - `subject` (text) - Email subject line
      - `body` (text) - Email body content (HTML/text)
      - `category` (text) - What the marketing is about
      - `created_by` (uuid) - User who created the template
      - `created_at` (timestamp)
      - `updated_at` (timestamp)
    
    - `marketing_campaigns`
      - `id` (uuid, primary key)
      - `name` (text) - Campaign name
      - `target_type` (text) - 'business' or 'individual'
      - `template_id` (uuid) - FK to email_templates
      - `status` (text) - 'draft', 'scheduled', 'sent'
      - `scheduled_at` (timestamp) - When to send (null for immediate)
      - `sent_at` (timestamp) - When it was actually sent
      - `recipients_count` (integer) - Total number of recipients
      - `created_by` (uuid) - User who created the campaign
      - `created_at` (timestamp)
      - `updated_at` (timestamp)
    
    - `campaign_recipients`
      - `id` (uuid, primary key)
      - `campaign_id` (uuid) - FK to marketing_campaigns
      - `email` (text) - Recipient email
      - `name` (text) - Recipient name
      - `company_name` (text, nullable) - For business recipients
      - `sent` (boolean) - Whether email was sent
      - `sent_at` (timestamp) - When it was sent
      - `opened` (boolean) - Whether email was opened
      - `opened_at` (timestamp) - When it was opened
      - `created_at` (timestamp)

  2. Security
    - Enable RLS on all tables
    - Add policies for authenticated users to manage their campaigns
*/

-- Create email templates table
CREATE TABLE IF NOT EXISTS email_templates (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  subject text NOT NULL,
  body text NOT NULL,
  category text NOT NULL DEFAULT 'general',
  created_by uuid REFERENCES auth.users(id) NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE email_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all email templates"
  ON email_templates FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Users can create email templates"
  ON email_templates FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update own email templates"
  ON email_templates FOR UPDATE
  TO authenticated
  USING (auth.uid() = created_by)
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can delete own email templates"
  ON email_templates FOR DELETE
  TO authenticated
  USING (auth.uid() = created_by);

-- Create marketing campaigns table
CREATE TABLE IF NOT EXISTS marketing_campaigns (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  target_type text NOT NULL CHECK (target_type IN ('business', 'individual')),
  template_id uuid REFERENCES email_templates(id),
  status text NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'sending', 'sent', 'failed')),
  scheduled_at timestamptz,
  sent_at timestamptz,
  recipients_count integer DEFAULT 0,
  created_by uuid REFERENCES auth.users(id) NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

ALTER TABLE marketing_campaigns ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all campaigns"
  ON marketing_campaigns FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Users can create campaigns"
  ON marketing_campaigns FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update campaigns"
  ON marketing_campaigns FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Users can delete own campaigns"
  ON marketing_campaigns FOR DELETE
  TO authenticated
  USING (auth.uid() = created_by);

-- Create campaign recipients table
CREATE TABLE IF NOT EXISTS campaign_recipients (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id uuid REFERENCES marketing_campaigns(id) ON DELETE CASCADE NOT NULL,
  email text NOT NULL,
  name text NOT NULL,
  company_name text,
  sent boolean DEFAULT false,
  sent_at timestamptz,
  opened boolean DEFAULT false,
  opened_at timestamptz,
  created_at timestamptz DEFAULT now()
);

ALTER TABLE campaign_recipients ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view campaign recipients"
  ON campaign_recipients FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Users can create campaign recipients"
  ON campaign_recipients FOR INSERT
  TO authenticated
  WITH CHECK (true);

CREATE POLICY "Users can update campaign recipients"
  ON campaign_recipients FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Users can delete campaign recipients"
  ON campaign_recipients FOR DELETE
  TO authenticated
  USING (true);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_email_templates_created_by ON email_templates(created_by);
CREATE INDEX IF NOT EXISTS idx_marketing_campaigns_created_by ON marketing_campaigns(created_by);
CREATE INDEX IF NOT EXISTS idx_marketing_campaigns_status ON marketing_campaigns(status);
CREATE INDEX IF NOT EXISTS idx_campaign_recipients_campaign_id ON campaign_recipients(campaign_id);
CREATE INDEX IF NOT EXISTS idx_campaign_recipients_sent ON campaign_recipients(sent);


-- ============================================
-- Migration: 20251107102114_fix_auto_enroll_trigger_add_created_by.sql
-- ============================================

/*
  # Fix Auto-Enroll Trigger to Include created_by

  1. Changes
    - Update the auto_enroll_candidate_from_booking function to include created_by field
    - This prevents null constraint violations when auto-enrolling candidates

  2. Security
    - Maintains existing RLS policies
*/

CREATE OR REPLACE FUNCTION auto_enroll_candidate_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_course_id uuid;
  v_user_id uuid;
BEGIN
  -- Only process if there's a candidate_id
  IF NEW.candidate_id IS NOT NULL THEN
    -- Get the course_id from the course_run
    SELECT course_id INTO v_course_id
    FROM course_runs
    WHERE id = NEW.course_run_id;

    -- Try to get the current user, fallback to a system user if not available
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
      -- Get the first user as a fallback (system user)
      SELECT id INTO v_user_id FROM auth.users LIMIT 1;
    END IF;

    IF v_course_id IS NOT NULL AND v_user_id IS NOT NULL THEN
      -- Check if candidate is already enrolled in this course run
      IF NOT EXISTS (
        SELECT 1 FROM candidate_courses
        WHERE candidate_id = NEW.candidate_id
        AND course_id = v_course_id
        AND course_run_id = NEW.course_run_id
      ) THEN
        -- Enroll the candidate
        INSERT INTO candidate_courses (
          candidate_id,
          course_id,
          course_run_id,
          enrollment_date,
          status,
          created_by
        ) VALUES (
          NEW.candidate_id,
          v_course_id,
          NEW.course_run_id,
          NOW(),
          'enrolled',
          v_user_id
        );

        RAISE NOTICE 'Auto-enrolled candidate % in course % (run: %)', NEW.candidate_id, v_course_id, NEW.course_run_id;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- Migration: 20251107110923_update_seats_booked_on_status_change.sql
-- ============================================

/*
  # Update seats_booked to handle status changes

  1. Changes
    - Modify the trigger function to only count "enrolled" candidates
    - When a candidate's status changes from "enrolled" to another status (like "cancelled"), decrement seats_booked
    - When a candidate's status changes to "enrolled", increment seats_booked

  2. Notes
    - This ensures that only actively enrolled candidates are counted in seats_booked
    - Cancelled or withdrawn candidates will not be counted
*/

-- Updated function to handle status changes
CREATE OR REPLACE FUNCTION update_seats_booked_from_candidate_courses()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Only increment if status is 'enrolled'
    IF NEW.course_run_id IS NOT NULL AND NEW.status = 'enrolled' THEN
      UPDATE course_runs
      SET seats_booked = COALESCE(seats_booked, 0) + 1
      WHERE id = NEW.course_run_id;
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    -- Only decrement if the deleted record was 'enrolled'
    IF OLD.course_run_id IS NOT NULL AND OLD.status = 'enrolled' THEN
      UPDATE course_runs
      SET seats_booked = GREATEST(COALESCE(seats_booked, 0) - 1, 0)
      WHERE id = OLD.course_run_id;
    END IF;
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    -- Handle course_run_id changes
    IF OLD.course_run_id IS NOT NULL AND OLD.course_run_id != NEW.course_run_id THEN
      -- Decrement from old course run only if old status was 'enrolled'
      IF OLD.status = 'enrolled' THEN
        UPDATE course_runs
        SET seats_booked = GREATEST(COALESCE(seats_booked, 0) - 1, 0)
        WHERE id = OLD.course_run_id;
      END IF;
    END IF;
    
    IF NEW.course_run_id IS NOT NULL AND OLD.course_run_id != NEW.course_run_id THEN
      -- Increment on new course run only if new status is 'enrolled'
      IF NEW.status = 'enrolled' THEN
        UPDATE course_runs
        SET seats_booked = COALESCE(seats_booked, 0) + 1
        WHERE id = NEW.course_run_id;
      END IF;
    END IF;
    
    -- Handle status changes within the same course run
    IF OLD.course_run_id = NEW.course_run_id THEN
      IF OLD.status = 'enrolled' AND NEW.status != 'enrolled' THEN
        -- Decrement when changing from enrolled to another status
        UPDATE course_runs
        SET seats_booked = GREATEST(COALESCE(seats_booked, 0) - 1, 0)
        WHERE id = NEW.course_run_id;
      ELSIF OLD.status != 'enrolled' AND NEW.status = 'enrolled' THEN
        -- Increment when changing to enrolled from another status
        UPDATE course_runs
        SET seats_booked = COALESCE(seats_booked, 0) + 1
        WHERE id = NEW.course_run_id;
      END IF;
    END IF;
    
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- Migration: 20251107110945_cancel_candidate_enrollment_on_booking_cancel.sql
-- ============================================

/*
  # Cancel candidate enrollment when booking is cancelled

  1. Changes
    - Create trigger to automatically update candidate_courses status to 'cancelled' when a booking is cancelled
    - This ensures that cancelled bookings don't count towards seats_booked

  2. Security
    - Maintains existing RLS policies
*/

-- Function to cancel candidate enrollment when booking is cancelled
CREATE OR REPLACE FUNCTION cancel_candidate_enrollment_on_booking_cancel()
RETURNS TRIGGER AS $$
BEGIN
  -- Check if booking status changed to 'cancelled'
  IF NEW.status = 'cancelled' AND OLD.status != 'cancelled' THEN
    -- Update the candidate_courses status to 'cancelled' if candidate_id is set
    IF NEW.candidate_id IS NOT NULL AND NEW.course_run_id IS NOT NULL THEN
      UPDATE candidate_courses
      SET status = 'cancelled'
      WHERE candidate_id = NEW.candidate_id
      AND course_run_id = NEW.course_run_id
      AND status = 'enrolled';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS cancel_candidate_enrollment_trigger ON bookings;
CREATE TRIGGER cancel_candidate_enrollment_trigger
  AFTER UPDATE ON bookings
  FOR EACH ROW
  WHEN (NEW.status = 'cancelled' AND OLD.status IS DISTINCT FROM 'cancelled')
  EXECUTE FUNCTION cancel_candidate_enrollment_on_booking_cancel();


-- ============================================
-- Migration: 20251107121730_fix_seats_booked_drop_booking_trigger.sql
-- ============================================

/*
  # Fix seats_booked double counting - drop booking trigger
  
  1. Changes
    - Drop the on_booking_change trigger that increments seats on bookings
    - Drop the update_course_run_seats function
    - Recalculate all seats_booked based on actual enrolled candidates
    
  2. Why
    - The booking trigger is causing double-counting
    - candidate_courses is the single source of truth for enrollment
    - Only the candidate_courses trigger should update seats_booked
*/

-- Drop the booking-based trigger
DROP TRIGGER IF EXISTS on_booking_change ON bookings;
DROP FUNCTION IF EXISTS update_course_run_seats();

-- Recalculate seats_booked for all course runs based on actual enrolled candidates
UPDATE course_runs cr
SET seats_booked = (
  SELECT COUNT(*)
  FROM candidate_courses cc
  WHERE cc.course_run_id = cr.id
  AND cc.status = 'enrolled'
);


-- ============================================
-- Migration: 20251107152112_fix_candidates_insert_policy_for_triggers.sql
-- ============================================

/*
  # Fix candidates insert policy for triggers
  
  1. Changes
    - Update the INSERT policy to allow triggers with SECURITY DEFINER to create candidates
    - Allow authenticated users to create candidates where they are the creator OR where the function is running as SECURITY DEFINER
    
  2. Why
    - The auto_create_candidates_from_booking trigger runs with SECURITY DEFINER
    - It needs to be able to create candidates with created_by set to an admin user
    - The current policy blocks this because auth.uid() doesn't match created_by when the trigger runs
*/

-- Drop the old restrictive policy
DROP POLICY IF EXISTS "Authenticated users can create candidates" ON candidates;

-- Create a new policy that allows:
-- 1. Users to create candidates where they are the creator
-- 2. Any creation when called from SECURITY DEFINER functions (bypasses RLS entirely)
CREATE POLICY "Authenticated users can create candidates"
  ON candidates
  FOR INSERT
  TO authenticated
  WITH CHECK (true);


-- ============================================
-- Migration: 20251107152307_make_candidates_created_by_nullable.sql
-- ============================================

/*
  # Make candidates.created_by nullable
  
  1. Changes
    - Change created_by column to allow NULL values
    
  2. Why
    - The auto_create_candidates_from_booking trigger needs to create candidates
    - Sometimes it may not find an admin user to assign as created_by
    - Making it nullable allows the system to track candidates even without a creator
    - This is acceptable for candidates auto-created from booking forms
*/

-- Make created_by nullable
ALTER TABLE candidates ALTER COLUMN created_by DROP NOT NULL;


-- ============================================
-- Migration: 20251107152849_update_auto_create_candidates_with_delegate_details.sql
-- ============================================

/*
  # Update auto-create candidates to use detailed delegate information
  
  1. Changes
    - Update trigger to extract delegate details from new structure
    - Extract name, NI number, DOB, address from delegates array
    - Store additional information in candidate record
    
  2. Behavior
    - Reads delegates array from form_data instead of delegate_names string
    - Creates candidates with complete information
*/

CREATE OR REPLACE FUNCTION auto_create_candidates_from_booking()
RETURNS TRIGGER AS $$
DECLARE
  v_delegate jsonb;
  v_delegate_name text;
  v_first_name text;
  v_last_name text;
  v_contact_email text;
  v_contact_phone text;
  v_course_name text;
  v_course_id uuid;
  v_course_run_id uuid;
  v_candidate_id uuid;
  v_admin_user_id uuid;
  v_name_parts text[];
  v_ni_number text;
  v_dob text;
  v_address text;
  v_postcode text;
BEGIN
  -- Only trigger when status changes to 'signed'
  IF NEW.status = 'signed' AND (OLD.status IS NULL OR OLD.status != 'signed') THEN
    
    -- Get the first admin user to use as created_by
    SELECT id INTO v_admin_user_id FROM users WHERE role = 'admin' LIMIT 1;
    
    v_contact_email := NEW.form_data->>'contact_email';
    v_contact_phone := NEW.form_data->>'contact_phone';
    v_course_name := NEW.form_data->>'course_name';
    
    -- Find the course_id based on course name
    IF v_course_name IS NOT NULL THEN
